import { Core, Camelize, Operation, DateInput, ResponseAdapter } from '@moralisweb3/common-core';
import { EvmAddressish, EvmChainish } from '@moralisweb3/common-evm-utils';
import { operations } from '../openapi';
declare type OperationId = 'requestChallengeEvm';
declare type BodyParams = operations[OperationId]['requestBody']['content']['application/json'];
declare type RequestParams = BodyParams;
declare type SuccessResponse = operations[OperationId]['responses']['201']['content']['application/json'];
export interface RequestChallengeEvmRequest extends Camelize<Omit<RequestParams, 'address' | 'chainId' | 'expirationTime' | 'notBefore'>> {
    address: EvmAddressish;
    chainId: EvmChainish;
    expirationTime?: DateInput;
    notBefore?: DateInput;
}
export declare type RequestChallengeEvmJSONRequest = ReturnType<typeof serializeRequest>;
export declare type RequestChallengeEvmJSONResponse = SuccessResponse;
export declare type RequestChallengeEvmResponse = ReturnType<typeof deserializeResponse>;
export interface RequestChallengeEvmResponseAdapter extends ResponseAdapter<RequestChallengeEvmResponse, RequestChallengeEvmJSONResponse> {
}
/** The back channel challenge containing the id to store on the api and the message to be signed by the user */
export declare const requestChallengeEvmOperation: Operation<RequestChallengeEvmRequest, RequestChallengeEvmJSONRequest, RequestChallengeEvmResponse, RequestChallengeEvmJSONResponse>;
declare function deserializeResponse(jsonResponse: RequestChallengeEvmJSONResponse): {
    id: string;
    message: string;
    profileId: string;
};
declare function serializeRequest(request: RequestChallengeEvmRequest, core: Core): {
    domain: string;
    chainId: string;
    address: string;
    statement: string | undefined;
    uri: string;
    expirationTime: DateInput | undefined;
    notBefore: DateInput | undefined;
    resources: string[] | undefined;
    timeout: number;
};
export {};
//# sourceMappingURL=requestChallengeEvmOperation.d.ts.map